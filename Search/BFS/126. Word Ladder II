Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same
Method: BFS/bidirectional BFS + DFS
T: O(n*26^l) => O(n*26^l/2), l = len(word), n = |wordList|, S: O(n+k*l), k = number of paths
用BFS建图， 用DFS寻找解
//单项广度优先搜索
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict(wordList.begin(), wordList.end());
        if(!dict.count(endWord)) return {};
        dict.erase(beginWord);
        dict.erase(endWord);
        
        unordered_map<string, int> steps{{beginWord, 1}};
        unordered_map<string, vector<string>> parents;
        queue<string> q;
        q.push(beginWord);
        
        vector<vector<string>> ans;
        
        const int l = beginWord.length();
        int step = 0;
        bool found = false;
        
        while(!q.empty() && !found){
            ++step;
            for(int size = q.size(); size>0; size--){
                const string p = q.front(); q.pop();
                string w = p;
                for(int i = 0; i< l; ++i){
                    const char ch = w[i];
                    for(int j = 'a'; j<='z'; ++j){
                        if(j == ch) continue;
                        w[i] = j;
                        if(w == endWord){
                            parents[w].push_back(p);
                            found = true;
                        }
                        else{
                            //Not a new word, but antoher transform
                            //with same number of steps
                            if(steps.count(w) && step<steps.at(w))
                                parents[w].push_back(p);
                        }
                        
                        if(!dict.count(w)) continue;
                        dict.erase(w);
                        q.push(w);
                        steps[w] = steps.at(p) + 1;
                        parents[w].push_back(p);
                    }
                    w[i] = ch;
                }
            }
        }
        if(found){
            vector<string> curr{endWord};
            getPaths(endWord, beginWord, parents, curr, ans);
        }
        
        return ans;
    }
private:
    void getPaths(const string &word, const string &beginWord, const unordered_map<string, vector<string>> &parents, vector<string> &curr, vector<vector<string>> &ans){
        if(word == beginWord){
            ans.push_back(vector<string>(curr.rbegin(), curr.rend()));
            return;
        }
        
        for(const string &p:parents.at(word)){
            curr.push_back(p);
            getPaths(p, beginWord, parents, curr, ans);
            curr.pop_back();
        }
    }
};
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        vector<vector<string>> ans;
        unordered_set<string> dict(wordList.begin(), wordList.end());
        if(!dict.count(endWord)) return ans;
        dict.erase(endWord);
        
        const int l = beginWord.length();
        unordered_set<string> q{beginWord}, p;
        unordered_map<string, vector<string>> children;
        bool found = false;
        
        while(!q.empty() && !found){
            
            for(const string &word: q)
                dict.erase(word);
            
            for(const string &word: q){
                string curr = word;
                for(int i = 0; i< l; ++i){
                    char ch = curr[i];
                    for(int j = 'a'; j<= 'z'; ++j){
                        curr[i] = j;
                        if(curr == endWord){
                            found = true;
                            children[word].push_back(curr);
                        }
                        else if(dict.count(curr) && !found){
                            p.insert(curr);
                            children[word].push_back(curr);
                        }
                    }
                    curr[i] = ch;
                }
            }
            
            swap(p, q);
            p.clear();
        }
        
        if(found){
            vector<string> path{beginWord};
            getPaths(beginWord, endWord, children, path, ans);
        }
        return ans;
    }
private:
    void getPaths(const string &word, const string &endWord, const unordered_map<string, vector<string>> &children, vector<string> &path, vector<vector<string>> &ans){
        if(word == endWord){
            ans.push_back(path);
            return;
        }
        
        const auto it = children.find(word);
        if(it == children.cend()) return;
        
        for(const string &child: it->second){
            path.push_back(child);
            getPaths(child, endWord, children, path, ans);
            path.pop_back();
        }
    }
};
